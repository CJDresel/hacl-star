(** This module provides direct access to all HACL* implementations *)

open SharedDefs

type bytes = CBytes.t
(** [bytes] is ultimately an alias for [Stdlib.Bytes.t], the type of buffers currently used
    throughout the library *)

(** {1 AEAD} *)
(** {2 Chacha20-Poly1305}
    Different implementations of Chacha20-Poly1305. A {{!EverCrypt.Chacha20_Poly1305}
    multiplexing interface} is also available.
*)

module Chacha20_Poly1305_32 : Chacha20_Poly1305
(** Portable C implementation of Chacha20-Poly1305 that runs on any 32-bit platform *)

module Chacha20_Poly1305_128 : Chacha20_Poly1305
(** 128-bit vectorized C implementation of Chacha20-Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX} Intel AVX} *)

module Chacha20_Poly1305_256 : Chacha20_Poly1305
(** 256-bit vectorized C implementation of Chacha20-Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX2} Intel AVX2} *)

(** {1 ECDH, EdDSA, and ECDSA} *)
(** {2 Curve25519}
    Different implementations of ECDH using Curve25519. A {{!EverCrypt.Curve25519}
    multiplexing interface} is also available.
*)

module Curve25519_51 : Curve25519
(** Portable C implementation that is optimized for use on 64-bit platforms that
    support 128-bit arithmetic, will still compile and execute on 32-bit platforms *)

module Curve25519_64 : Curve25519
(** Hybrid C/assembly implementation: the field arithmetic functions are in Intel assembly
    (generated by Vale) and rely on the {{!AutoConfig2.ADX} Intel ADX} and {{!AutoConfig2.BMI2} BMI2} instruction sets; the elliptic
    curve functions and the main API are in portable C *)

(** {2 Ed25519}
    EdDSA using Curve25519*)

module Ed25519 : EdDSA
(** Portable implementation *)

(** {2 P-256} *)

module P256 : sig

  (** Buffers have the following size constraints:
      - [pk]: 64 bytes, corresponding to the "raw" representation of an elliptic curve point (see {!section:points})
      - [sk], [k]: 32 bytes
      - [signature]: 64 bytes
      - [pt]: depends on which hash function is being used (see {!section:ecdsa})
  *)

  (** {1:points Point representation and conversions}
      Elliptic curve points have 2 32-byte coordinates {i (x, y)} and can be represented in 3 ways:
      - "raw" form (64 bytes): the concatenation of the 2 coordinates
      - "compressed" form (33 bytes): the first byte is either [\x02] or [\x03], followed
      by {i y}
      - "uncompressed" form (65 bytes): the first byte is always [\04], followed by the "raw" form

      These functions convert points between these representations:
*)

  val raw_to_compressed : p:bytes -> result:bytes -> unit
    (** [raw_to_compressed p result] converts a "raw" point [p] (64 bytes) to a "compressed" point [result] (33 bytes) *)

  val raw_to_uncompressed : p:bytes -> result:bytes -> unit
    (** [raw_to_uncompressed p result] converts a "raw" point [p] (64 bytes) to an "uncompressed" point [result] (65 bytes) *)

  val compressed_to_raw : p:bytes -> result:bytes -> bool
    (** [compressed_to_raw p result] converts a "compressed" point [p] (33 bytes) to a "raw" point [result] (64 bytes).
        Returns true if successful. *)

  val uncompressed_to_raw : p:bytes -> result:bytes -> bool
    (** [uncompressed_to_raw p result] converts an "uncompressed" point [p] (65 bytes) to a "raw" point [result] (64 bytes).
        Returns true if successful. *)

  (** {1 Point validation} *)

  val valid_sk : sk:bytes -> bool
    (** [valid_sk sk] checks if the contents of [sk] (32 bytes) can be used as a secret key or as a signing secret.
    This is the case if 0 < [sk] < the order of the curve. *)

  val valid_pk : pk:bytes -> bool
  (** [valid_pk pk] checks if the contents of [pk] (64 bytes) is a valid public key, as specified in {{: https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final}NIST SP 800-56A}. *)

  (** {1 ECDH}
      ECDH key agreement protocol
  *)

  (* TODO: consistent names with those in Curve25519? *)
  val dh_initiator : sk:bytes -> pk:bytes -> bool
  (** [dh_initiator sk pk] takes a 32-byte secret key [sk] and writes the corresponding
      64-byte public key in [pk]. *)

  val dh_responder : sk:bytes -> pk:bytes -> shared:bytes -> bool
  (** [dh_responder sk pk shared] takes a 32-byte secret key [sk] and another party's 64-byte public
      key and writes the 64-byte ECDH shared key in [shared]. Buffer [shared] must be distinct from
      [pk]. *)

  (** {1:ecdsa ECDSA}
      ECDSA signing and signature verification functions

      The [sign] and [verify] functions included in this module
      take the digest of the message to be signed ([pt]), requiring users to use a cryptographic hash function
      of their choosing before calling them. In this case, [pt] needs to be at least 32 bytes long.
  *)

  include ECDSA

  (** The functions in the other submodules take the unhashed message [pt] and first hash it using their corresponding
      version of the SHA-2 hash function. In this case, there is no minimum size requirement for [pt]. *)

  module SHA2_256 : ECDSA
  module SHA2_384 : ECDSA
  module SHA2_512 : ECDSA

end
(** ECDSA and ECDH functions using P-256 *)


(** {1 Hashing } *)
(** {2 SHA-2}

    Portable C implementations of SHA-2.
    Multiplexing interfaces for {{!EverCrypt.SHA2_224}SHA-224} and {{!EverCrypt.SHA2_256}SHA-256} are also available.
*)

module SHA2_224 : HashFunction
(** Direct hasing with SHA-224

The [digest] buffer must match the digest size of SHA-224, which is 28 bytes.
*)

module SHA2_256 : HashFunction
(** Direct hashing with SHA-256

The [digest] buffer must match the digest size of SHA-256, which is 32 bytes.
*)


module SHA2_384 : HashFunction
(** Direct hashing with SHA-384

The [digest] buffer must match the digest size of SHA-384, which is 48 bytes.
*)


module SHA2_512 : HashFunction
(** Direct hashing with SHA-512

The [digest] buffer must match the digest size of SHA-512, which is 64 bytes.
*)



(** {2 SHA-3}

    Portable C implementations of SHA-3
*)

module SHA3_224 : HashFunction
(** Direct hashing with SHA3-224

The [digest] buffer must match the digest size of SHA3-224, which is 28 bytes.
*)

module SHA3_256 : HashFunction
(** Direct hashing with SHA3-256

The [digest] buffer must match the digest size of SHA3-256, which is 32 bytes.
*)

module SHA3_384 : HashFunction
(** Direct hashing with SHA3-384

The [digest] buffer must match the digest size of SHA3-384, which is 48 bytes.
*)

module SHA3_512 : HashFunction
(** Direct hashing with SHA3-512

The [digest] buffer must match the digest size of SHA3-512, which is 64 bytes.
*)

module Keccak : sig
  val shake128 : pt:bytes -> digest:bytes -> unit
  (** [shake128 pt digest] hashes [pt] using SHAKE-128 and outputs the result in [digest]. *)

  val shake256 : pt:bytes -> digest:bytes -> unit
  (** [shake256 pt digest] hashes [pt] using SHAKE-256 and outputs the result in [digest]. *)

  val keccak : rate:int -> capacity:int -> suffix:int -> pt:bytes -> digest:bytes -> unit
    (** Direct access to the general Keccak function, of which all the SHA-3 and SHAKE functions
        are {{:https://en.wikipedia.org/wiki/SHA-3#Instances}instances}. While the library
        does run some sanity checks for the parameters, users should be extremely careful
        if using the Keccak function directly. *)
end
(** SHAKE-128, SHAKE-256, and the general Keccak function

    Contrary to other Keccak/SHA-3 variants, SHAKE-128 and SHAKE-256 produce digests of
    any size. When calling these functions, it will correspond to the size of the [digest] buffer.
*)

(** {2 BLAKE2}
    The BLAKE2 hash function has 2 variants:
    - BLAKE2b, optimised for 64-bit architectures
    - BLAKE2s, optimised for 8- to 32-bit architectures
*)

module Blake2b_32 : Blake2
(** Portable BLAKE2b implementation *)

module Blake2b_256 : Blake2
(** Vectorized BLAKE2b implementation, requiring {{!AutoConfig2.AVX2} Intel AVX2} *)

module Blake2s_32 : Blake2
(** Portable BLAKE2s implementation *)

module Blake2s_128 : Blake2
(** Vectorized BLAKE2s implementation, requiring {{!AutoConfig2.AVX} Intel AVX} *)

(** {2 Legacy (deprecated)}
Legacy algorithms, which are {b not suitable for cryptographic applications.} *)

module MD5 : HashFunction [@@deprecated]
(** Direct hashing with MD5

{b This function should not be used for cryptographic applications! }

The [digest] buffer must match the digest size of MD5, which is 16 bytes. *)

module SHA1 : HashFunction [@@deprecated]
(** Direct hashing with SHA-1

{b This function should not be used for cryptographic applications! }

The [digest] buffer must match the digest size of SHA-1, which is 20 bytes. *)


(** {1 MACs}
Message authentication codes

{{!mac}Multiplexing interfaces} for these algorithms are also available.
*)

(** {2 HMAC} *)

module HMAC_SHA2_256 : MAC
(** Portable C implementation of HMAC-SHA-256 *)

module HMAC_SHA2_384 : MAC
(** Portable C implementation of HMAC-SHA-384 *)

module HMAC_SHA2_512 : MAC
(** Portable C implementation of HMAC-SHA-512 *)

(** {2 Poly1305} *)

module Poly1305_32 : MAC
(** Portable C implementation of Poly1305 *)

module Poly1305_128 : MAC
(** Vectorized C implementation of Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX} Intel AVX} *)

module Poly1305_256 : MAC
(** Vectorized C implementation of Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX2} Intel AVX2} *)


(** {1 NaCl } *)

module NaCl : sig
  val box_beforenm : bytes -> bytes -> bytes -> bool
  module Easy : sig
    val box : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_afternm : bytes -> bytes -> bytes -> bytes -> bool
    val box_open_afternm : bytes -> bytes -> bytes -> bytes -> bool
    val secretbox : bytes -> bytes -> bytes -> bytes -> bool
    val secretbox_open : bytes -> bytes -> bytes -> bytes -> bool
  end
  module Detached : sig
    val box : bytes -> bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open : bytes -> bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_afternm : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open_afternm : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val secretbox : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val secretbox_open : bytes -> bytes -> bytes -> bytes -> bytes -> bool
  end
end

(** {1 Key derivation} *)
(** {2 HKDF} *)

module HKDF_SHA2_256 : HKDF
module HKDF_SHA2_512 : HKDF

(** {1 Randomness (not verified)} *)

module RandomBuffer : sig
  val randombytes : out:bytes -> bool
  (** [randombytes out] attempts to fill [out] with random bytes and returns true if successful. *)


end
(** A randomness function implemented with platform dependant code for Unix and Windows

    The [randombytes] function is handwritten, unverified C code.
    In Unix, it is implemented using the {{: https://man7.org/linux/man-pages/man2/getrandom.2.html} [getrandom]} syscall, with a fallback to [/dev/urandom].
    In Windows, it is implemented using {{: https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom} [CryptGenRandom]}.
*)
