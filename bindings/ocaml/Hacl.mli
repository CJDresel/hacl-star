(** This module provides direct access to all HACL* implementations *)

open SharedDefs

type bytes = CBytes.t
(** [bytes] is ultimately an alias for [Stdlib.Bytes.t], the type of buffers currently used
    throughout the library *)

module RandomBuffer : sig
  val randombytes : bytes -> bool
end


(** {1 AEAD} *)
(** {2 Chacha20-Poly1305}
    Different implementations of Chacha20-Poly1305. A {{!EverCrypt.Chacha20_Poly1305}
    multiplexing interface} is also available.
*)

module Chacha20_Poly1305_32 : Chacha20_Poly1305
(** Portable C implementation of Chacha20-Poly1305 that runs on any 32-bit platform *)

module Chacha20_Poly1305_128 : Chacha20_Poly1305
(** 128-bit vectorized C implementation of Chacha20-Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX} Intel AVX} *)

module Chacha20_Poly1305_256 : Chacha20_Poly1305
(** 256-bit vectorized C implementation of Chacha20-Poly1305 that runs on any platform that supports {{!AutoConfig2.AVX2} Intel AVX2} *)

(** {1 ECDH, EdDSA, and ECDSA} *)
(** {2 Curve25519}
    Different implementations of ECDH using Curve25519. A {{!EverCrypt.Curve25519}
    multiplexing interface} is also available.
*)

module Curve25519_51 : Curve25519
(** Portable C implementation that is optimized for use on 64-bit platforms that
    support 128-bit arithmetic, will still compile and execute on 32-bit platforms *)

module Curve25519_64 : Curve25519
(** Hybrid C/assembly implementation: the field arithmetic functions are in Intel assembly
    (generated by Vale) and rely on the {{!AutoConfig2.ADX} Intel ADX} and {{!AutoConfig2.BMI2} BMI2} instruction sets; the elliptic
    curve functions and the main API are in portable C *)

(** {2 Ed25519}
    EdDSA using Curve25519*)

module Ed25519 : EdDSA
(** Portable implementation *)

(** {2 P-256} *)

module P256 : sig

  (** Buffers have the following size constraints:
      - [pk]: 64 bytes, corresponding to the "raw" representation of an elliptic curve point (see {!section:points})
      - [sk], [k]: 32 bytes
      - [signature]: 64 bytes
      - [pt]: depends on which hash function is being used (see {!section:ecdsa})
  *)

  (** {3:points Point representation and conversions}
      Elliptic curve points have 2 32-byte coordinates {i (x, y)} and can be represented in 3 ways:
      - "raw" form (64 bytes): the concatenation of the 2 coordinates
      - "compressed" form (33 bytes): the first byte is either [\x02] or [\x03], followed
      by {i y}
      - "uncompressed" form (65 bytes): the first byte is always [\04], followed by the "raw" form

      These functions convert points between these representations:
*)

  val raw_to_compressed : p:bytes -> result:bytes -> unit
    (** [raw_to_compressed p result] converts a "raw" point [p] (64 bytes) to a "compressed" point [result] (33 bytes) *)

  val raw_to_uncompressed : p:bytes -> result:bytes -> unit
    (** [raw_to_uncompressed p result] converts a "raw" point [p] (64 bytes) to an "uncompressed" point [result] (65 bytes) *)

  val compressed_to_raw : p:bytes -> result:bytes -> bool
    (** [compressed_to_raw p result] converts a "compressed" point [p] (33 bytes) to a "raw" point [result] (64 bytes).
        Returns true if successful. *)

  val uncompressed_to_raw : p:bytes -> result:bytes -> bool
    (** [uncompressed_to_raw p result] converts an "uncompressed" point [p] (65 bytes) to a "raw" point [result] (64 bytes).
        Returns true if successful. *)

  (** {3 Point validation} *)

  val valid_sk : sk:bytes -> bool
    (** [valid_sk sk] checks if the contents of [sk] (32 bytes) can be used as a secret key or as a signing secret.
    This is the case if 0 < [sk] < the order of the curve. *)

  val valid_pk : pk:bytes -> bool
  (** [valid_pk pk] checks if the contents of [pk] (64 bytes) is a valid public key, as specified in {{: https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final}NIST SP 800-56A}. *)

  (** {3 ECDH}
      ECDH key agreement protocol
  *)

  (* TODO: consistent names with those in Curve25519? *)
  val dh_initiator : sk:bytes -> pk:bytes -> bool
  (** [dh_initiator sk pk] takes a 32-byte secret key [sk] and writes the corresponding
      64-byte public key in [pk]. *)

  val dh_responder : sk:bytes -> pk:bytes -> shared:bytes -> bool
  (** [dh_responder sk pk shared] takes a 32-byte secret key [sk] and another party's 64-byte public
      key and writes the 64-byte ECDH shared key in [shared]. Buffer [shared] must be distinct from
      [pk]. *)

  (** {3:ecdsa ECDSA}
      ECDSA signing and signature verification functions

      The [sign] and [verify] functions included in this module
      take the digest of the message to be signed ([pt]), requiring users to use a cryptographic hash function
      of their choosing before calling them. In this case, [pt] needs to be at least 32 bytes long.
  *)

  include ECDSA

  (** The functions in the other submodules take the unhashed message [pt] and first hash it using their corresponding
      version of the SHA-2 hash function. In this case, there is no minimum size requirement for [pt]. *)

  module SHA2_256 : ECDSA
  module SHA2_384 : ECDSA
  module SHA2_512 : ECDSA

end
(** ECDSA and ECDH functions using P-256 *)


(** {1 Hashing } *)
(** {2 SHA-2} *)

module SHA2_224 : HashFunction
module SHA2_256 : HashFunction
module SHA2_384 : HashFunction
module SHA2_512 : HashFunction

(** {2 SHA-3} *)

module SHA3_224 : HashFunction
module SHA3_256 : HashFunction
module SHA3_384 : HashFunction
module SHA3_512 : HashFunction
module Keccak : sig
  val keccak : int -> int -> int -> bytes -> bytes -> unit
  val shake128 : bytes -> bytes -> unit
  val shake256 : bytes -> bytes -> unit
end

(** {2 BLAKE2}
    The BLAKE2 hash function has 2 variants:
    - BLAKE2b, optimised for 64-bit architectures
    - BLAKE2s, optimised for 8- to 32-bit architectures
*)

module Blake2b_32 : Blake2
(** Portable BLAKE2b implementation *)

module Blake2b_256 : Blake2
(** Vectorized BLAKE2b implementation, requiring {{!AutoConfig2.AVX2} Intel AVX2} *)

module Blake2s_32 : Blake2
(** Portable BLAKE2s implementation *)

module Blake2s_128 : Blake2
(** Vectorized BLAKE2s implementation, requiring {{!AutoConfig2.AVX} Intel AVX} *)

(** {2 Legacy (deprecated)} *)

module MD5 : HashFunction [@@deprecated]
module SHA1 : HashFunction [@@deprecated]


(** {1 MACs} *)
(** {2 HMAC} *)

module HMAC_SHA2_256 : MAC
module HMAC_SHA2_384 : MAC
module HMAC_SHA2_512 : MAC

(** {2 Poly1305} *)

module Poly1305_32 : MAC
module Poly1305_128 : MAC
module Poly1305_256 : MAC

(** {1 NaCl } *)

module NaCl : sig
  val box_beforenm : bytes -> bytes -> bytes -> bool
  module Easy : sig
    val box : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_afternm : bytes -> bytes -> bytes -> bytes -> bool
    val box_open_afternm : bytes -> bytes -> bytes -> bytes -> bool
    val secretbox : bytes -> bytes -> bytes -> bytes -> bool
    val secretbox_open : bytes -> bytes -> bytes -> bytes -> bool
  end
  module Detached : sig
    val box : bytes -> bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open : bytes -> bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_afternm : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val box_open_afternm : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val secretbox : bytes -> bytes -> bytes -> bytes -> bytes -> bool
    val secretbox_open : bytes -> bytes -> bytes -> bytes -> bytes -> bool
  end
end

(** {1 Key derivation} *)
(** {2 HKDF} *)

module HKDF_SHA2_256 : HKDF
module HKDF_SHA2_512 : HKDF
